CREATE OR REPLACE TYPE BODY T_TEST IS 



STATIC FUNCTION ODCIAGGREGATEINITIALIZE(SCTX IN OUT T_TEST) RETURN NUMBER IS 
BEGIN 
SCTX := T_TEST(0, 0); 
RETURN ODCICONST.SUCCESS; 
END; 



MEMBER FUNCTION ODCIAGGREGATEITERATE(SELF IN OUT T_TEST, STR IN VARCHAR2) RETURN NUMBER IS 
MTYPE NUMBER := SUBSTR(STR, 1, INSTR(STR, ',') - 1);
V_JE NUMBER := SUBSTR(STR, INSTR(STR, ',') + 1, INSTR(STR, ',', 1, 2) - INSTR(STR, ',') - 1);
V_RS NUMBER := SUBSTR(STR, INSTR(STR, ',', 1, 2) + 1);
BEGIN 
SELF.JE := SELF.JE + (2 - MTYPE) * V_JE + (MTYPE - 1) * V_RS * SELF.JE / CASE SELF.RS WHEN 0 THEN 1 ELSE SELF.RS END; 
SELF.RS := SELF.RS + V_RS;
RETURN ODCICONST.SUCCESS; 
END; 



MEMBER FUNCTION ODCIAGGREGATETERMINATE(SELF IN T_TEST, RETURNVALUE OUT NUMBER, FLAGS IN NUMBER)
RETURN NUMBER IS 
BEGIN 
RETURNVALUE := SELF.JE; 
RETURN ODCICONST.SUCCESS;
END; 




MEMBER FUNCTION ODCIAGGREGATEMERGE(SELF IN OUT T_TEST, CTX2 IN T_TEST) RETURN NUMBER IS 
BEGIN 
NULL;
RETURN ODCICONST.SUCCESS;
END;


END;






CREATE OR REPLACE TYPE T_TEST AS OBJECT ( 
JE NUMBER, 
RS NUMBER, 
STATIC FUNCTION ODCIAGGREGATEINITIALIZE(SCTX IN OUT T_TEST) RETURN NUMBER, 
MEMBER FUNCTION ODCIAGGREGATEITERATE(SELF IN OUT T_TEST, STR IN VARCHAR2) RETURN NUMBER, 
MEMBER FUNCTION ODCIAGGREGATETERMINATE(SELF IN T_TEST, RETURNVALUE OUT NUMBER, FLAGS IN NUMBER)
RETURN NUMBER, 
MEMBER FUNCTION ODCIAGGREGATEMERGE(SELF IN OUT T_TEST, CTX2 IN T_TEST) RETURN NUMBER 
)



CREATE OR REPLACE FUNCTION F_TEST(P_STR IN VARCHAR2) RETURN NUMBER 
AGGREGATE USING T_TEST; 







CREATE TABLE TEST (ID NUMBER(3),MTYPE NUMBER(1),JE NUMBER(3),RS NUMBER(3));
INSERT INTO TEST VALUES (1,1,8,2);
INSERT INTO TEST VALUES (2,1,10,2);
INSERT INTO TEST VALUES (3,2,20,5);
INSERT INTO TEST VALUES (4,1,5,1);
INSERT INTO TEST VALUES (5,1,40,4);
INSERT INTO TEST VALUES (6,1,100,10); 
INSERT INTO TEST VALUES (7,2,100,20);



SELECT ID, 
MTYPE, 
JE, 
F_TEST(MTYPE || ',' || JE || ',' || RS) OVER(ORDER BY ID) NJE, 
RS,
SUM(RS) OVER(ORDER BY ID) NRS 
FROM TEST;
























利用自定义分析函数的一个例子 
=========================================================== 
作者: yangtingkun(http://yangtingkun.itpub.net)
发表于: 2008.12.25 23:19
分类: ORACLE 
出处: http://yangtingkun.itpub.net/post/468/476123
--------------------------------------------------------------- 

今天同事给我推荐了PUB上一个帖子：http://www.itpub.net/thread-1104948-1-1.html。不过我看到的时候，有人已经用10g的MODEL语法实现了。

这里给出9I上的实现，不过这个实现需要利用Oracle的自定义聚集函数。





其实Oracle的定制功能是很强的，比如这个例子中，楼主的需求其实就是实现一个逻辑很复杂的分析函数。

SQL> CREATE TABLE TEST (ID NUMBER(3),MTYPE NUMBER(1),JE NUMBER(3),RS NUMBER(3));

表已创建。

SQL> INSERT INTO TEST VALUES (1,1,8,2);

已创建 1 行。

SQL> INSERT INTO TEST VALUES (2,1,10,2);

已创建 1 行。

SQL> INSERT INTO TEST VALUES (3,2,20,5);

已创建 1 行。

SQL> INSERT INTO TEST VALUES (4,1,5,1);

已创建 1 行。

SQL> INSERT INTO TEST VALUES (5,1,40,4);

已创建 1 行。

SQL> INSERT INTO TEST VALUES (6,1,100,10); 

已创建 1 行。

SQL> INSERT INTO TEST VALUES (7,2,100,20);

已创建 1 行。

SQL> COMMIT;

提交完成。

SQL> SELECT * FROM TEST;

ID MTYPE JE RS
---------- ---------- ---------- ----------
1 1 8 2
2 1 10 2
3 2 20 5
4 1 5 1
5 1 40 4
6 1 100 10
7 2 100 20

已选择7行。

楼主希望得到的结果如下：

SQL> SELECT ID, 
2 MTYPE, 
3 JE, 
4 F_TEST(MTYPE || ',' || JE || ',' || RS) OVER(ORDER BY ID) NJE, 
5 RS,
6 SUM(RS) OVER(ORDER BY ID) NRS 
7 FROM TEST;

ID MTYPE JE NJE RS NRS
---------- ---------- ---------- ---------- ---------- ----------
1 1 8 8 2 2
2 1 10 18 2 4
3 2 20 40.5 5 9
4 1 5 45.5 1 10
5 1 40 85.5 4 14
6 1 100 185.5 10 24
7 2 100 340.083333 20 44

已选择7行。

简单解释一下，当MTYPE列的值为1时，NJE为JE值的累加。

当MTYPE列的值为2时，NJE的值为上一条记录中NJE的值除以NSR的值，乘以当前记录的RS的值，再加上前一条记录的NJE的值。

比如ID为3的记录NJE的值等于18（前一条记录NJE的值）+ 5（被记录RS值）* 18（前一条记录NJE的值）/ 4 （前一条记录NSR的值）。

由于NJE既是计算结果，又是参与计算的列，分析函数无法使用这个列。

这时最简单的方法莫过于人为的定制一个分析函数：

SQL> CREATE OR REPLACE TYPE T_TEST AS OBJECT ( 
2 JE NUMBER, 
3 RS NUMBER, 
4 STATIC FUNCTION ODCIAGGREGATEINITIALIZE(SCTX IN OUT T_TEST) RETURN NUMBER, 
5 MEMBER FUNCTION ODCIAGGREGATEITERATE(SELF IN OUT T_TEST, STR IN VARCHAR2) RETURN NUMBER, 
6 MEMBER FUNCTION ODCIAGGREGATETERMINATE(SELF IN T_TEST, RETURNVALUE OUT NUMBER, FLAGS IN NUMBER)
RETURN NUMBER, 
7 MEMBER FUNCTION ODCIAGGREGATEMERGE(SELF IN OUT T_TEST, CTX2 IN T_TEST) RETURN NUMBER 
8 )
9 /

类型已创建。

SQL> CREATE OR REPLACE TYPE BODY T_TEST IS 
2 STATIC FUNCTION ODCIAGGREGATEINITIALIZE(SCTX IN OUT T_TEST) RETURN NUMBER IS 
3 BEGIN 
4 SCTX := T_TEST(0, 0); 
5 RETURN ODCICONST.SUCCESS; 
6 END; 
7 
8 MEMBER FUNCTION ODCIAGGREGATEITERATE(SELF IN OUT T_TEST, STR IN VARCHAR2) RETURN NUMBER IS 
9 MTYPE NUMBER := SUBSTR(STR, 1, INSTR(STR, ',') - 1);
10 V_JE NUMBER := SUBSTR(STR, INSTR(STR, ',') + 1, INSTR(STR, ',', 1, 2) - INSTR(STR, ',') - 1);
11 V_RS NUMBER := SUBSTR(STR, INSTR(STR, ',', 1, 2) + 1);
12 BEGIN 
13 SELF.JE := SELF.JE + (2 - MTYPE) * V_JE + (MTYPE - 1) * V_RS * SELF.JE / CASE SELF.RS WHEN 0 TH
EN 1 ELSE SELF.RS END; 
14 SELF.RS := SELF.RS + V_RS;
15 RETURN ODCICONST.SUCCESS; 
16 END; 
17 
18 MEMBER FUNCTION ODCIAGGREGATETERMINATE(SELF IN T_TEST, RETURNVALUE OUT NUMBER, FLAGS IN NUMBER)
RETURN NUMBER IS 
19 BEGIN 
20 RETURNVALUE := SELF.JE; 
21 RETURN ODCICONST.SUCCESS;
22 END; 
23 
24 MEMBER FUNCTION ODCIAGGREGATEMERGE(SELF IN OUT T_TEST, CTX2 IN T_TEST) RETURN NUMBER IS 
25 BEGIN 
26 NULL;
27 RETURN ODCICONST.SUCCESS;
28 END;
29 END;
30 /

类型主体已创建。

SQL> CREATE OR REPLACE FUNCTION F_TEST(P_STR IN VARCHAR2) RETURN NUMBER 
2 AGGREGATE USING T_TEST; 
3 /

函数已创建。

调用这个分析函数的SQL，在上面已经显示了。

虽然分析函数逻辑要求比较复杂，而且需要输入3个列的值，但是可以通过变通的方法使得3个列的值同时输入给函数。

虽然逻辑比较复杂，但是在PL/SQL中就不算什么了，而TYPE中的SELF变量本身就保存前一条记录的计算结果，因此所有问题都迎刃而解。

唯一需要额外处理的是，由于RS初始值为0，因此会出现被0除的错误，这里需要将分母的0转换为1。




